package appseer;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import appseer.ManifestFetcher.Component;

public class VulnerabilityFinder {
	
	//Constants for Cursor.state
	public static final int VULNERABLE = 0;
	public static final int NOT_VULNERABLE = 1;
	public static final int WARNING = 2;
	
	//Constants for vulnerable components list log
	//Location corresponding to OUTPUT_DIR in vulnerableComponents.sh
	public static String OUTPUT_PATH;// = "/Users/Vincenzo/Desktop/vuln_tool/outputs/";
	public static final String VULNERABLE_OUTPUT_FILE = "vulnerable.txt";
	public static final String SAFE_OUTPUT_FILE = "safe.txt";
	
	private String appName;
	private long startTime;
	private long endTime;
	
	//Sink classes the VulnerabilityFinder will stop to
	private String sinkClass; 
	private String sourceClass; 
	//Source and sink methods the VulnerabilityFinder is trying to link together
	private MethodDeclaration source;
	private MethodDeclaration sink;
	
	//FileCursor object to navigate through hierarchy
	private FileCursor cursor;
	//Number of analyzed paths
	private int numberOfPaths;
	
	//Regex pattern for comments
	private static final Pattern commentsPattern = Pattern.compile("(\\/\\/.*)|(\\/\\*.*)|(.*\\*\\/)| ");
	//Regex pattern for method declaration and invocation
	private static final Pattern methodDeclPattern = Pattern.compile(".*((public |private |protected |package |final |abstract |synchronized )+)([a-zA-Z0-9_]+) *([a-zA-Z0-9_]+) *\\((.*)\\) *\\{");
	
	private static final Pattern methodInvokPattern = Pattern.compile("(super\\.)?([a-zA-Z0-9_]+)\\(([a-zA-Z0-9_,()\"\\. ]*)\\)");
	//This is the old, working solution
	//private static final Pattern methodInvokPattern = Pattern.compile(" *(super\\.|)?([a-zA-Z0-9_]+)\\((.*)\\);");
	
	private Matcher commentsMatcher;
	private Matcher methodDeclMatcher;
	private Matcher methodInvokMatcher;
	
	//Boolean representing if a string invocation of the sink method is present
	boolean isSinkMethod;
	//Boolean representing if the source class requires permission to be launched
	boolean requiresPermission;
	
	//Writer fields
	private File vulnerableOutput, safeOutput;
	private FileWriter vfw, sfw;
	private BufferedWriter vbw, sbw;
	
	public VulnerabilityFinder(String appName, String outdir){
	
		this.appName = appName;
		OUTPUT_PATH = outdir;
		
		commentsMatcher = commentsPattern.matcher("");
		methodDeclMatcher = methodDeclPattern.matcher("");
		methodInvokMatcher = methodInvokPattern.matcher("");
		
		try{
			
			vulnerableOutput = new File(OUTPUT_PATH+"/"+VULNERABLE_OUTPUT_FILE);
			vfw = new FileWriter(vulnerableOutput);
			vbw = new BufferedWriter(vfw);
			//Can immediately write the package name
			vbw.write(ManifestFetcher.getPackageName()+"\n");
			
			safeOutput = new File(OUTPUT_PATH+"/"+SAFE_OUTPUT_FILE);
			sfw = new FileWriter(safeOutput);
			sbw = new BufferedWriter(sfw);
			sbw.write(ManifestFetcher.getPackageName()+"\n");
			
		} catch (Exception e){
			
			System.out.println("Failed to open the output file");
			
		}
		
	}
	
	/**
	 * Setter methods to reuse the same VulnerabilityFinder object throughout the whole app
	 * 
	 */
	
	public void setMethods(MethodDeclaration source, MethodDeclaration sink){
		
		this.source = source;
		this.sink = sink;
		
	}
	
	public void setHierarchy(List<String> newHierarchy, boolean requiresPermission){
		
		this.sinkClass = newHierarchy.get(0);
		this.sourceClass = newHierarchy.get(newHierarchy.size()-1);
		this.requiresPermission = requiresPermission;
		this.cursor = new FileCursor(newHierarchy, source);
		this.numberOfPaths = 0;
				
	}
	
	public void evaluateComponent(){
		
		startTime = System.currentTimeMillis();
		isSinkMethod = isSinkMethodPresent();
		//If sink method is not even present in the whole hierarchy, no need to look for a pattern source-sink
		if(isSinkMethod)
			pathFinder();
		endTime = System.currentTimeMillis();
		evaluatePath();
		
	}
	
	/**
	 * 
	 * Recursively checks if a given hierarchy of java sources is vulnerable according to the presence of a path from
	 * this.source to this.sink. If a path is found, the hierarchy is not vulnerable. Otherwise, it is.
	 * 
	 */
	public void pathFinder(){
		
		//Dead path due to end of hierarchy
		if(cursor.getFile().equals(this.sinkClass)){
			this.numberOfPaths++;
			cursor.setState(VULNERABLE);
			return;
		}
		
		//Found sink method
		if(cursor.getMethod().getMethodName().equals(sink.getMethodName()) && cursor.getMethod().getMethodNParameters() == sink.getMethodNParameters()){
			cursor.setState(NOT_VULNERABLE);
			return;
		}
		
		try{
		
			File currFile = new File(cursor.getFile());
			FileReader fr = new FileReader(currFile);
			BufferedReader br = new BufferedReader(fr);
			List<MethodInvocation> matches = new ArrayList<>();
			List<MethodDeclaration> declaredMethods = getDeclaredMethodsWithCurrentName(currFile);
			
			//cursor.getMethod() is not in the current class. Try up in the hierarchy
			if(declaredMethods.size() == 0){
				
				cursor.climbHierarchy();
				pathFinder();
				cursor.downHierarchy();
				
			} else {
				
				String line, superInvoke, methodName, params;
				MethodDeclaration method;
	
				for(int i = 0; i<declaredMethods.size(); i++){
					
					//Position the reader at the next declared method matching cursor.getMethod()
					cursor.setCurrMethod(declaredMethods.get(i));
					moveToNextDeclaration(br);
					int bracketsCount = 1;
					
					//Examine its code
					while(cursor.getState() == VULNERABLE && (line = br.readLine()) != null && bracketsCount > 0){
						
						if(line.contains("{"))
							bracketsCount++;
						if(line.contains("}"))
							bracketsCount--;
						
						line = trimInitialSpaces(line);
						commentsMatcher.reset(line);
						
						//Exclude comments
						if(!commentsMatcher.matches()){
						
							matches.clear();
							methodInvokMatcher.reset(line);
							while(methodInvokMatcher.find()){
								
								superInvoke = (methodInvokMatcher.group(1) != null && methodInvokMatcher.group(1).equals("super.")) ? "super." : null;
								methodName = methodInvokMatcher.group(2);
								params = methodInvokMatcher.group(3);
								
								matches.add(new MethodInvocation(methodName, params, superInvoke));

							}
							
							for(MethodInvocation m : matches){
						
								method = new MethodDeclaration(null, null, m.getMethodName(), m.getParameters());
								cursor.setCurrMethod(method);
								
								//Found invocation of superClass method
								if(m.isSuper()){
									cursor.climbHierarchy();
									pathFinder();
									cursor.downHierarchy();
								} else {
									pathFinder();		
								}
								
							}

						}
						
					}
					
					//Dead path due to no more invocations
					this.numberOfPaths++;
					
				}
				
				//cursor.setCurrMethod(oldMethod);
				br.close();
				fr.close();
		
			}
			
			
		} catch (Exception e){
			
			System.out.println(e.getMessage() + " - aborting");
			return;
			
		}
		
	}

	
	/**
	 * Utility method to get the number of parameters of a method
	 * 
	 */
	public static int getNParameters(String paramsLine){
		
		if(paramsLine.isEmpty())
			return 0;
		else return paramsLine.split(",").length;
		
	}
	
	/**
	 * 
	 * Utility method to remove initial spaces in a line
	 * 
	 */
	public String trimInitialSpaces(String line){
		
		StringBuffer sb = new StringBuffer();
		int i = 0;
		
		while(!line.isEmpty() && i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\t'))
			i++;
		
		if(i >= line.length())
			sb.append(" ");
		else
			sb.append(line.substring(i));
		
		return sb.toString();
		
	}
	
	/**
	 * 
	 * This method returns a list of MethodDeclaration objects that match the name and the number of parameters of 
	 * cursor.getMethod()
	 * 
	 */
	public List<MethodDeclaration> getDeclaredMethodsWithCurrentName(File f) throws IOException{
		
		String line, accessType, returnType, name;
		int nParams;
		List<MethodDeclaration> declared = new ArrayList<>();
		MethodDeclaration currentM = cursor.getMethod();
		FileReader fr = new FileReader(f);
		BufferedReader br = new BufferedReader(fr);
		
		while((line = br.readLine()) != null){
			
			line = trimInitialSpaces(line);
			methodDeclMatcher.reset(line);
			
			if(methodDeclMatcher.matches()){
				
				accessType = methodDeclMatcher.group(1);
				returnType = methodDeclMatcher.group(3).trim();
				name = methodDeclMatcher.group(4).trim();
				nParams = getNParameters(methodDeclMatcher.group(5));
				
				if(currentM.getMethodName().equals(name) && currentM.getMethodNParameters() == nParams){
					//System.out.println("Added method "+name+"("+methodDeclMatcher.group(5)+"");
					declared.add(new MethodDeclaration(accessType, returnType, name, methodDeclMatcher.group(5)));
				}
			
			}
		}
		
		return declared;
		
	}
	
	/**
	 * 
	 * This method increments the position from which the given BufferedReader will start reading, stopping when a declaration
	 * of cursor.getMethod is found
	 * 
	 */
	public void moveToNextDeclaration(BufferedReader br) throws IOException{
		
		String line;
		//String accessType, returnType;
		String name;
		int nParams;
		
		while((line = br.readLine()) != null){

			line = trimInitialSpaces(line);
			methodDeclMatcher.reset(line);
			
			if(methodDeclMatcher.matches()){
				
				MethodDeclaration m = cursor.getMethod();
				
				//accessType = methodDeclMatcher.group(1);
				//returnType = methodDeclMatcher.group(3).trim();
				name = methodDeclMatcher.group(4).trim();
				nParams = getNParameters(methodDeclMatcher.group(5));
				
				if(m.getMethodName().equals(name) && m.getMethodNParameters() == nParams){ //&& m.getReturnType().equals(returnType)
					//System.out.println("Positioned at "+line+", matching cursor method "+cursor.getMethod().getMethodName());
					break;
				}
				
			}
			
		}
		
		return;
		
	}
	
	/**
	 * 
	 * Once the search is done, print the state of the cursor.
	 * 
	 */
	public void evaluatePath(){
		
		boolean isToAttack = false;
		int state = cursor.getState();
		String vulnerable = null, permission = "";
		
		if(state == NOT_VULNERABLE)
			vulnerable = "safe";
		else if(state == VULNERABLE && isSinkMethod){
			vulnerable = "vulnerable but "+sink.getMethodName()+" is in hierarchy";
			isToAttack = true;
		} else if(state == VULNERABLE && !isSinkMethod){
			vulnerable = "vulnerable";
			isToAttack = true;
		}
		
		if(requiresPermission)
			permission = " (requires permission)";
		
		writeToOutputFile(isToAttack);
		
		String[] steps = sourceClass.split("/");
		String c = steps[steps.length-1];
		
		System.out.println("Class "+c+": "+vulnerable+permission + " (" + (endTime - startTime) + "ms)");
		
	}
	
	/**
	 * 
	 * This method just checks for the invocation of the sink method in the whole hierarchy, except for the last class (Service) where it is defined. For further checks.
	 * 
	 */
	public boolean isSinkMethodPresent(){
		
		File f;
		FileReader fr;
		BufferedReader br;
		String line;
		List<MethodInvocation> matches = new ArrayList<>();
		
		try{
		
		for(int i = 1; i<cursor.getHierarchy().size(); i++){
			
			f = new File(cursor.getHierarchy().get(i));
			fr = new FileReader(f);
			br = new BufferedReader(fr);
			
			while((line = br.readLine()) != null){
				
				line = trimInitialSpaces(line);
				methodInvokMatcher.reset(line);
				
				while(methodInvokMatcher.find()){
				
					int n = getNParameters(methodInvokMatcher.group(3));
					//System.out.println("Found invocation "+methodInvokMatcher.group(2)+", "+n+" parameters");
					if(methodInvokMatcher.group(2).equals(sink.getMethodName()) && n == sink.getMethodNParameters()){
						br.close();
						fr.close();
						return true;
					}
				
				}
				
			}
			
		}
	
		} catch (Exception e){
			
			System.out.println(e.getMessage() + "- exiting");
			
		}
		
		return false;
		
	}
	
	/**
	 * 
	 * Utility method to log a vulnerable component to the right output file
	 * 
	 */
	public void writeToOutputFile(boolean isToAttack){
		
		String toWrite;
		
		try{
	
			//Process line to write: remove absolute path, extension and replace slashes with dots 
			toWrite = sourceClass.substring(ManifestFetcher.PKG_ROOT.length(), sourceClass.length()-5);
			toWrite = toWrite.replace("/", ".");
			
			if(isToAttack)
				vbw.write(toWrite+"\n");
			else
				sbw.write(toWrite+"\n");
		
		} catch (Exception e){
			
			System.out.println("Failed to write log - exiting");
			
		}	
		
	}
	
	/**
	 * 
	 * Utility method to write the MainActivity component to both the output files
	 */
	public void writeMainActivityToOutput(Component c){
		
		String toWrite = (c != null) ? c.getName() : "null";
		try{
			
			vbw.write(toWrite+"\n");
			sbw.write(toWrite+"\n");
			
		} catch (Exception e){
			
			System.out.println("Failed to write log - exiting");
			
		}
		
	}
	
	/**
	 * 
	 * Close the output stream
	 * 
	 */
	public void closeOutput(){
		
		try{
			vbw.close();
			vfw.close();
			sbw.close();
			sfw.close();
		} catch (Exception e){
			System.out.println(e.getMessage());
		}
		
	}
	
	/**
	 * This class represents the signature of a Method
	 * 
	 */
	public static class MethodDeclaration{
		
		private String accessType;
		private String name;
		private String returnType;
		private String params;
		private int nParameters;
		
		public MethodDeclaration(String accessType, String returnType, String name, String params){
			
			this.accessType = accessType;
			this.returnType = returnType;
			this.name = name;
			this.params = params;
			this.nParameters = getNParameters(params);
			
		}
		
		/**
		 * 
		 * Getter methods
		 * 
		 */
		public String getMethodName(){
			return this.name;
		}
		
		public String getReturnType(){
			return this.returnType;
		}
		
		public String getParams(){
			return this.params;
		}
		
		public int getMethodNParameters(){
			return this.nParameters;
		}
		
		@Override
		public String toString(){
			return this.name+"("+this.params+")";
		}
		
	}

	/**
	 * This class represents the invocation of a Method
	 * 
	 */
	
	public static class MethodInvocation{
		
		private String name;
		private String params;
		private int nParameters;
		private boolean isSuper;
		
		public MethodInvocation(String name, String params, String superInvoc){
			
			this.name = name;
			this.params = params;
			this.nParameters = getNParameters(params);
			this.isSuper = (superInvoc != null);
			
		}
		
		/**
		 * 
		 * Getter methods
		 * 
		 */
		public String getMethodName(){
			return this.name;
		}
		
		public String getParameters(){
			return this.params;
		}
		
		public int getMethodNParameters(){
			return this.nParameters;
		}
		
		public boolean isSuper(){
			return this.isSuper;
		}
		
	}
}
